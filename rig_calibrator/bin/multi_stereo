#!/usr/bin/env python

# Copyright (c) 2021, United States Government, as represented by the
# Administrator of the National Aeronautics and Space Administration.
#
# All rights reserved.
#
# The "ISAAC - Integrated System for Autonomous and Adaptive Caretaking
# platform" software is licensed under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with the
# License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Prepare for and then run stereo on many image pairs, and produce a fuse mesh.
"""

import argparse, os, re, shutil, subprocess, sys, glob
import numpy as np

# Find and import rig_utils.py
curr_path = os.path.abspath(sys.path[0])
libexec_path = os.path.dirname(curr_path) + "/libexec" # install dir for rig_utils.py
sys.path.insert(0, curr_path)
sys.path.insert(0, libexec_path)
import rig_utils

def process_args(args):
    """
    Set up the parser and parse the args.
    """

    parser = argparse.ArgumentParser(description = "Parameters for texrecon.")
    
    parser.add_argument("--rig_config",  dest="rig_config", default="",
                        help = "Rig configuration file.")
    
    parser.add_argument("--rig_sensor", dest="rig_sensor", default="",
                        help="Which rig sensor images to texture. Must be among the " + \
                        "sensors specified via --rig_config.")

    parser.add_argument("--camera_poses", dest="camera_poses",
                        default="", help= "Read images and camera poses from this list.")

    parser.add_argument("--out_dir", dest="out_dir",
                        default="", help="The directory where to write the textured mesh " + \
                        "and other data.")
    
    # Note how the percent sign below is escaped, by writing: %%
    parser.add_argument("--undistorted_crop_win", dest="undistorted_crop_win", default = "",
                        help = "The dimensions of the central image region to keep after "   + \
                        "undistorting an image and before uisng it in texturing. Normally "  + \
                        "85%% - 90%% of distorted (actual) image dimensions would do. "      + \
                        "This would need revisiting. Suggested the Astrobee images: "        + \
                        "sci_cam: '1250 1000' nav_cam: '1100 776'. haz_cam: '250 200'.")
    
    args = parser.parse_args()

    return args

def sanity_checks(args):

    if args.camera_poses == "":
        raise Exception("The path to the list having input images and poses was not specified.")

    if args.rig_config == "":
        raise Exception("The path to the rig configuration was not specified.")

    if args.rig_sensor == "":
        raise Exception("The rig sensor to use for texturing was not specified.")

    if args.out_dir == "":
        raise Exception("The path to the output directory was not specified.")

    if args.undistorted_crop_win == "":
        raise Exception("The undistorted crop win was not specified.")
    
if __name__ == "__main__":

    args = process_args(sys.argv)
    sanity_checks(args)
    rig_utils.mkdir_p(args.out_dir)

    # Read the images and camera poses
    (images, world_to_cam) \
             = rig_utils.parse_images_and_camera_poses(args.camera_poses, args.rig_sensor)

    # Write undistorted images
    base_dir = os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))
    extension = '.tif' # use lossless .tif extension for undistorted images
    extra_opts = []
    (undist_intrinsics_file, undistorted_images, undist_dir) \
                        = rig_utils.undistort_images(args, images, base_dir, extension, extra_opts)

    # Write camera poses in the format of ASP and voxblox
    (widx, widy, f, cx, cy) = rig_utils.read_intrinsics(undist_intrinsics_file)
    undist_image_dict = {}
    for image in undistorted_images:
        # Use the image name without dir and extension as a key
        base = os.path.basename(image)
        base = os.path.splitext(base)[0]
        undist_image_dict[base] = image

    count = 0
    for dist_image in images:

        base = os.path.basename(dist_image)
        base = os.path.splitext(base)[0]
        if base not in undist_image_dict:
            raise Exception("Cannot find undistorted image for: "  + dist_image)
        undist_image = undist_image_dict[base]
        tsai_file = os.path.splitext(undist_image)[0] + ".tsai"

        # Find the camera-to-world transform
        cam_to_world = np.linalg.inv(world_to_cam[count])
        rig_utils.write_tsai_camera_file(tsai_file, f, cx, cy, cam_to_world)
        
        # For use with voxblox later
        cam_to_world_file = os.path.splitext(undist_image)[0] + "_cam2world.txt"
        rig_utils.write_cam_to_world_matrix(cam_to_world_file, cam_to_world)
        
        count = count + 1

    print("Found " + str(len(undistorted_images)) + " undistorted images.")
    print("Wrote: " + str(count) + " cameras.")

